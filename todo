* Нужно:

  1. **восстановить номера** прямо в тексте заголовков (чтобы остались в MD),
  2. **разрезать по главам** (по `h1` или другое правило),
  3. прогнать **каждую главу через pandoc → GFM Markdown**, сохранив **картинки в отдельные папки** и корректно проставив ссылки на них.

---

# План реализации (с шагами и точками интеграции)

## 0) Директории и CLI

* Структура вывода:

  ```
  out/
    01.intro.md
    02.setup.md
    ...
    media/
      ch01/
      ch02/
      ...
    SUMMARY.md  (или README.md)
  ```
* В `cli.py` добавляем сабкоманду, например:
  `from-html-pandoc --input input.html --split-level 1 --out out --media-dir media`

---

## 1) «Восстановить» номера в заголовках (до разрезания)

**Подход:** один прогон через pandoc (HTML→HTML) с Lua-фильтром.

* Команда (нормализация HTML + вставка номеров):

  ```
  pandoc input.html \
    --from=html --to=html \
    --standalone \
    --lua-filter=restore_numbers.lua \
    -o _numbered.html
  ```

* Что делает `restore_numbers.lua`:

  1. **Собирает карту ToC:** в начале документа проходит инлайны/блоки и вылавливает ссылки вида `[#hXXXX]`. Из текста пункта извлекает `"<номер> <заголовок>"` и сохраняет карту `anchor_id → "номер заголовок"`.
  2. **Обновляет заголовки:** при обработке каждого `Header`:

     * если его `identifier` (или первый вложенный `Span`/`Div`) совпадает с якорём из карты ToC — **препендит** `"<номер> "` к тексту заголовка;
     * если в карте нет — **fallback:** если включён флаг `--number-sections`, берёт вычисленный номер секции у Pandoc и тоже препендит.
  3. (Опционально) **Удаляет весь блок оглавления** (если он не нужен в финальном MD), чтобы он не попал в главу/разметку.

* Результат: `_numbered.html`, где **в самих заголовках уже есть «1», «1.1», «1.2.3»** и т.п.

> Почему именно так: номера станут частью текста и гарантированно доживут до Markdown, независимо от дальнейших конвертаций.

---

## 2) Разрезать на главы (после восстановления номеров)

**Подход:** небольшой Python-скрипт (или расширение твоего `splitter.py`) — режет `_numbered.html` по `h1` (или уровню из `--split-level`), не ломая внутренние якоря и картинки.

* Логика:

  1. Прочитать `_numbered.html`, распарсить `body`.
  2. Итерация по детям `body`:

     * при встрече `h{level}` — начать новую «главу»; всё до следующего `h{level}` входит в текущую главу;
     * заголовок включается в главу первым элементом.
  3. Имя файла: `NN.<slug(title)>.html` (title — текст из `h{level}` уже с номером).
  4. Сохранить каждый фрагмент как самостоятельный, валидный HTML (обернуть в `<div>` или минимальный каркас).

* Вывод:

  ```
  _chapters/
    01.intro.html
    02.installation.html
    ...
  ```

> Примечание: если некоторые «главы» у Google размечены не `h1`, а «списочными шапками», добавь расширенное правило («новая глава = `h1` ИЛИ элемент с id `h…` и крупным шрифтом»). Это можно сделать флагом `--split-selector`.

---

## 3) Конвертировать каждую главу в Markdown (с медиа)

**Подход:** один вызов pandoc **на каждую** главу, с отдельной папкой медиа на главу.

* Для главы `NN.<slug>.html`:

  ```
  mkdir -p out/media/chNN
  pandoc _chapters/NN.<slug>.html \
    --from=html \
    --to=gfm \
    --extract-media=out/media/chNN \
    --wrap=none \
    -o out/NN.<slug>.md
  ```

* Зачем `--extract-media` **на каждую главу**:

  * pandoc скопирует все `img` из HTML-фрагмента в `out/media/chNN/` и **перепишет пути** в сгенерированном `.md` так, чтобы они ссылались на эти файлы.
  * Избегаем конфликтов имён и облегчаем диффы.

* Опциональные флаги:

  * `--reference-links` — если хочешь выносить ссылки вниз.
  * `--shift-heading-level-by` — если требуется «сдвинуть» уровни заголовков внутри глав (например, сделать корневой заголовок `#`).
  * `--markdown-headings=atx` — форсить `#`-стиль.

---

## 4) Навигация и внутренние ссылки

* **SUMMARY.md / README.md**: скрипт проходит `out/*.md`, берёт первую строку (заголовок), генерирует оглавление:

  ```
  - [1 Введение](01.vvedenie.md)
  - [2 Установка](02.ustanovka.md)
  ...
  ```
* **Внутренние якоря:** если в исходнике были ссылки вида `[#hXXXX]` между разделами:

  * во время **сплита** построить `id → файл` (первая секция, содержащая элемент с этим `id`).
  * постпроцесс по каждому `.md`: ссылки `(#hXXXX)` переписать на `(<target-file>.md#<slugified-anchor>)`.
  * (Если якоря нужны редко, можно отложить до итерации №2.)

---

## 5) Включение в ваш проект

* `config.py`: добавить `input_format=html`, `split_level`, `media_dir`, `use_pandoc=true`.
* `validators.py`: пропустить DOCX-проверки для HTML.
* `cli.py`:

  * новая команда `from-html-pandoc` с шагами 1→2→3→4.
  * флаги: `--split-level`, `--media-dir`, `--remove-toc`, `--keep-temp` (оставлять `_numbered.html`/`_chapters/` для отладки).
* `splitter.py`: переиспользовать/расширить для HTML (selector-базированный сплит).
* `navigation.py`: генерировать `SUMMARY.md`.

---

## 6) Быстрый «скелет» команд

```bash
# 1) восстановить номера в заголовках
pandoc input.html \
  --from=html --to=html \
  --standalone \
  --lua-filter=restore_numbers.lua \
  -o _numbered.html

# 2) разрезать на главы (вызов твоего splitter’а)
python -m yourpkg.splitter \
  --input _numbered.html \
  --split-level 1 \
  --out _chapters

# 3) конвертировать каждую главу в MD с отдельной медиапапкой
for f in _chapters/*.html; do
  bn=$(basename "$f" .html)      # NN.slug
  ch=${bn%%.*}                    # NN
  mkdir -p out/media/ch${ch}
  pandoc "$f" \
    --from=html --to=gfm \
    --extract-media=out/media/ch${ch} \
    --wrap=none \
    -o "out/${bn}.md"
done

# 4) сгенерировать SUMMARY.md
python -m yourpkg.navigation --input out --output out/SUMMARY.md
```

---

## 7) Риски и страховки

* **ToC с «чужими» пунктами:** фильтр должен брать только ссылки `href="#..."` и уметь распознавать `^\d+(\.\d+)*\s+` в тексте.
* **Неполная карта:** если для заголовка нет записи в ToC — fallback на `--number-sections`.
* **Стили/«шапки» не в `<h*>`:** добавить опциональный `--split-selector` (например, `h1, li[id^="h"]`).
* **Дубликаты имён картинок:** per-chapter media-dir решает.
* **Относительные пути:** запускать шаг 3 из корня проекта и писать относительные пути вида `media/chNN/<file>` (pandoc так и сделает).

---

